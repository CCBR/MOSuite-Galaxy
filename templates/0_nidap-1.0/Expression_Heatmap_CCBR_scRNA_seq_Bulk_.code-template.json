{
	"codeTemplate": "L2P_Heatmap <- function({{{Counts_Matrix}}},{{{Sample_Metadata}}}) {\n    ## This function uses pheatmap to draw a heatmap, scaling first by rows\n    ## (with samples in columns and genes in rows)\n\n    ## --------- ##\n    ## Libraries ##\n    ## --------- ##\n\n    library(colorspace)\n    library(dendsort)\n    library(ComplexHeatmap)\n    library(dendextend)\n    library(tibble)\n    library(stringr)\n    library(RColorBrewer)\n    library(dplyr)\n    library(grid)\n    library(gtable)\n    library(gridExtra)\n    library(gridGraphics)\n\n    ## -------------------------------- ##\n    ## User-Defined Template Parameters ##\n    ## -------------------------------- ##\n\n    #Basic Parameters:\n    counts_matrix <- {{{Counts_Matrix}}}\n    sample_metadata <- {{{Sample_Metadata}}}\n    gene_column_name <- \"{{{Gene_Column_Name}}}\"\n    sample_name_column <- \"{{{Sample_Name_Column}}}\"\n    sample_label_column = \"{{{Sample_Labels_Column}}}\"\n    samples_to_include = {{{Samples_to_Include}}}\n    \n    #Gene Parameters\n    include_all_genes <- {{{Include_All_Genes}}}\n    filter_top_genes_by_variance = {{{Filter_Top_Genes_by_Variance}}}\n    top_genes_by_variance_to_include <- {{{Top_Genes_by_Variance_to_Include}}}\n    specific_genes_to_include_in_heatmap = \"{{{Specific_Genes_to_Include_in_Heatmap}}}\" \n    cluster_genes <- {{{Cluster_Genes}}}\n    gene_distance_metric <- \"{{{Gene_Distance_Metric}}}\"\n    gene_clustering_method <- \"{{{Gene_Clustering_Method}}}\"\n    display_gene_dendrograms = {{{Display_Gene_Dendrogram}}}\n    display_gene_names <- {{{Display_Gene_Names}}}\n    center_and_rescale_expression <- {{{Center_and_Rescale_Expression}}}\n\n\n    #Sample Parameters\n    cluster_samples <- {{{Cluster_Samples}}}\n    arrange_sample_columns <- {{{Arrange_Sample_Columns}}}\n    order_by_gene_expression <- {{{Order_by_Gene_Expression}}}\n    gene_to_order_columns <- \"{{{Gene_to_Order_Columns}}}\"\n    gene_expression_order <- \"{{{Gene_Expression_Order}}}\"\n    smpl_distance_metric <- \"{{{Sample_Distance_Metric}}}\"\n    smpl_clustering_method <- \"{{{Sample_Clustering_Method}}}\"\ndisplay_smpl_dendrograms <- {{{Display_Sample_Dendrograms}}}\n    reorder_dendrogram <- {{{Reorder_Sample_Dendrogram}}}\n    reorder_dendrogram_order <- {{{Reorder_Sample_Dendrogram_Order}}}\n    display_sample_names <- {{{Display_Sample_Names}}}\n    manually_rename_samples <- {{{Manually_Rename_Samples}}}\n    samples_to_rename <- {{{Samples_to_Rename}}}\n\n    #Annotation\n    group_columns <- {{{Group_Columns}}}\n    assign_group_colors <- {{{Assign_Group_Colors}}}\n    assign_color_to_sample_groups <- {{{Assign_Color_to_Sample_Groups}}}\n    group_colors <- {{{Group_Colors}}}\n\n    #Visual Parameters:\n    heatmap_color_scheme <- \"{{{Heatmap_Color_Scheme}}}\"\n    autoscale_heatmap_color <- {{{Autoscale_Heatmap_Color}}}\n    set_min_heatmap_color <- {{{Set_Min_Heatmap_Color}}}\n    set_max_heatmap_color <- {{{Set_Max_Heatmap_Color}}}\n    aspect_ratio <- \"{{{Aspect_Ratio}}}\"\n    legend_font_size <- {{{Legend_Font_Size}}} \n    gene_name_font_size <- {{{Gene_Name_Font_Size}}}\n    sample_name_font_size <- {{{Sample_Name_Font_Size}}}\n    display_numbers <- {{{Display_Numbers}}}\n\n    #Advanced Parameters\n    return_z_scores <- {{{Return_Z_Scores}}}\n\n\n    ##--------------- ##\n    ## Error Messages ##\n    ## -------------- ##\n\n    if(include_all_genes == TRUE && filter_top_genes_by_variance == TRUE){\n        stop(\"ERROR: Choose only one of 'Include all genes' or 'Filter top genes by variance' as TRUE\")\n    }\n\n    if((cluster_samples == TRUE && arrange_sample_columns == TRUE) | (arrange_sample_columns == TRUE && order_by_gene_expression == TRUE) | \n    (order_by_gene_expression == TRUE && cluster_samples == TRUE)) {\n     stop(\"ERROR: Only one of 'Cluster Samples', 'Arrange sample columns', or 'order by gene expression' may be set as TRUE at one time. Leaving all three of these FALSE will result in the sample column order matching the 'Samples to Include'.\")   \n    }\n\n    ## --------- ##\n    ## Functions ##\n    ## --------- ##\n\n    getourrandomcolors<-function(k){\n        seed=10\n        n <- 2e3\n        ourColorSpace <- colorspace::RGB(runif(n), runif(n), runif(n))\n        ourColorSpace <- as(ourColorSpace, \"LAB\")\n        currentColorSpace <- ourColorSpace@coords\n        # Set iter.max to 20 to avoid convergence warnings.\n        set.seed(seed)\n        km <- kmeans(currentColorSpace, k, iter.max=20)\n        return( unname(hex(LAB(km$centers))))\n    }\n\n    ## Begin pal() color palette function∂:\n    pal = function (n, h=c(237, 43), c=100, l=c(70, 90), power=1, fixup=TRUE, gamma=NULL, alpha=1, ...) {\n        if (n < 1L) {\n            return(character(0L))\n        }\n        h <- rep(h, length.out = 2L)\n        c <- c[1L]\n        l <- rep(l, length.out = 2L)\n        power <- rep(power, length.out = 2L)\n        rval <- seq(1, -1, length = n)\n        rval <- hex(\n            polarLUV(\n                L = l[2L] - diff(l) * abs(rval)^power[2L], \n                C = c * abs(rval)^power[1L],\n                H = ifelse(rval > 0, h[1L], h[2L])\n            ),\n            fixup=fixup, ...\n        )\n        if (!missing(alpha)) {\n            alpha <- pmax(pmin(alpha, 1), 0)\n            alpha <- format(as.hexmode(round(alpha * 255 + 1e-04)), \n                width = 2L, upper.case = TRUE)\n            rval <- paste(rval, alpha, sep = \"\")\n        }\n        return(rval)\n    } \n    # End pal() color palette function:\n\n    ## Begin doheatmap() function:\n    doheatmap <- function(dat, clus, clus2, ht, rn, cn, col, dispnum) {\n        #require(pheatmap)\n        #require(dendsort)\n        col.pal <- np[[col]]\n        if (FALSE) {\n            col.pal = rev(col.pal)\n        }\n        # Define metrics for clustering\n        drows1 <- gene_distance_metric\n        dcols1 <- smpl_distance_metric\n        minx = min(dat)\n        maxx = max(dat)\n        if (autoscale_heatmap_color) {\n            breaks = seq(minx, maxx, length=100)\n            legbreaks = seq(minx, maxx, length=5)\n        } else {\n            breaks = seq(set_min_heatmap_color, set_max_heatmap_color, length=100)\n            legbreaks = seq(set_min_heatmap_color, set_max_heatmap_color, length=5)\n        }\n        breaks = sapply(breaks, signif, 4)\n        legbreaks = sapply(legbreaks, signif, 4)\n        # Run cluster method using \n        hcrow = hclust(dist(dat), method=gene_clustering_method)\n        hc = hclust(dist(t(dat)), method=smpl_clustering_method)\n\n        if (FALSE) {\n            sort_hclust <- function(...) as.hclust(rev(dendsort(as.dendrogram(...))))\n        } else {\n            sort_hclust <- function(...) as.hclust(dendsort(as.dendrogram(...)))\n        }\n        if (clus) {\n            colclus <- sort_hclust(hc)\n        } else {\n            colclus = FALSE\n        }\n        if (clus2) {\n            rowclus <- sort_hclust(hcrow)\n        } else {\n            rowclus = FALSE\n        }\n        if (display_smpl_dendrograms) {\n            smpl_treeheight <- 25\n        } else {\n            smpl_treeheight <- 0\n        }\n        if (display_gene_dendrograms) {\n            gene_treeheight <- 25\n        } else {\n            gene_treeheight <- 0\n        }\n        hm.parameters <- list(\n            dat, \n            color=col.pal,\n            legend_breaks=legbreaks,\n            legend=TRUE,\n            scale=\"none\",\n            treeheight_col=smpl_treeheight,\n            treeheight_row=gene_treeheight,\n            kmeans_k=NA,\n            breaks=breaks,\n            display_numbers=dispnum,\n            number_color = \"black\",\n            fontsize_number = 8,\n            height=80,\n            cellwidth = NA, \n            cellheight = NA, \n            fontsize= legend_font_size,   \n            fontsize_row=gene_name_font_size,\n            fontsize_col=sample_name_font_size,\n            show_rownames=rn, \n            show_colnames=cn,\n            cluster_rows=rowclus, \n            cluster_cols=clus,\n            clustering_distance_rows=drows1, \n            clustering_distance_cols=dcols1,\n            annotation_col = annotation_col,\n            annotation_colors = annot_col,\n            labels_col = labels_col\n        )\n        mat = t(dat)\n        callback = function(hc, mat) {\n            dend = rev(dendsort(as.dendrogram(hc)))\n            if(reorder_dendrogram == TRUE) {\n                dend %>% dendextend::rotate(reorder_dendrogram_order) -> dend\n            } else {\n                dend %>% dendextend::rotate(c(1:nobs(dend))) \n            }\n            as.hclust(dend)\n        }\n\n        ## Make Heatmap\n        phm <- do.call(\"pheatmap\", c(hm.parameters, list(clustering_callback=callback)))\n        \n    }\n    # End doheatmap() function.\n\n    ## --------------- ##\n    ## Main Code Block ##\n    ## --------------- ##\n\n    ## Build different color spectra options for heatmap:\n    np0 = pal(100) \n    np1 = diverge_hcl(100, c=100, l=c(30, 80), power=1) # Blue to Red\n    np2 = heat_hcl(100, c=c(80, 30), l=c(30, 90), power=c(1/5, 2)) # Red to Vanilla\n    np3 = rev(heat_hcl(100, h=c(0, -100), c=c(40, 80), l=c(75, 40), power=1)) # Violet to Pink\n    np4 = rev(colorRampPalette(brewer.pal(10, \"RdYlBu\"))(100)) #Red to yellow to blue\n    np5 = colorRampPalette(c(\"steelblue\",\"white\", \"red\"))(100)  # Steelblue to White to Red\n\n    ## Gather list of color spectra and give them names for the GUI to show.\n    np = list(np0, np1, np2, np3, np4, np5)\n    names(np) = c(\"Default\",\"Blue to Red\",\"Red to Vanilla\",\"Violet to Pink\",\"Bu Yl Rd\",\"Bu Wt Rd\")\n\n    ## Parse input counts matrix. Subset by samples.\n    df1 <- counts_matrix\n    # Swap out Gene Name column name, if it's not 'Gene'.\n    if(gene_column_name != \"Gene\"){\n        # Drop original Gene column\n        df1 = df1[,!(colnames(df1)%in% c(\"Gene\")) ]\n        # Rename column to Gene\n        colnames(df1)[which(colnames(df1) == gene_column_name)] <- 'Gene'\n    }\n    # Get sample columns\n    samples_to_include <- samples_to_include[samples_to_include != gene_column_name]\n    samples_to_include <- samples_to_include[samples_to_include != \"Gene\"]\n    samples_to_include <- samples_to_include[samples_to_include != \"GeneName\"]\n\n    # Build new counts matrix containing only sample subset chosen by user.\n    df1 <- df1[,append(\"Gene\", samples_to_include)]\n    df.orig = df1\n    df.orig %>% dplyr::group_by(Gene) %>% summarise_all(funs(mean)) -> df\n    df.mat = df[ , (colnames(df) != \"Gene\" )] %>% as.data.frame\n    #df %>% dplyr::mutate(Gene = stringr::str_replace_all(Gene, \"_\", \" \")) -> df\n    row.names(df.mat) <- df$Gene\n    rownames(df.mat) <- str_wrap(rownames(df.mat),30) #for really long geneset names\n    df.mat <- as.data.frame(df.mat)\n\n    ## Subset counts matrix by genes.\n    # Toggle to include all genes in counts matrix (in addition to any user-submitted gene list).\n    if (include_all_genes == FALSE) {\n        # Add user-submitted gene list (optional).\n        genes_to_include_parsed = c()\n        genes_to_include_parsed = strsplit(specific_genes_to_include_in_heatmap, \" \")[[1]]\n        #genes_to_include_parsed = gsub(\"_\",\" \",genes_to_include_parsed)\n        df.mat[genes_to_include_parsed,] -> df.final.extra.genes\n        if(filter_top_genes_by_variance == TRUE) {\n            # Want to filter all genes by variance.\n            df.final = as.matrix(df.mat)\n            var <- matrixStats::rowVars(df.final)\n            df <- as.data.frame(df.final)\n            rownames(df) <- rownames(df.final)\n            df.final <- df\n            df.final$var <- var\n            df.final %>% rownames_to_column(\"Gene\") -> df.final \n            df.final %>% dplyr::arrange(desc(var)) -> df.final\n            df.final.extra.genes = dplyr::filter(df.final, Gene %in% genes_to_include_parsed)\n            df.final = df.final[1:top_genes_by_variance_to_include,]\n            df.final = df.final[complete.cases(df.final),]\n            # Rbind user gene list to variance-filtered gene list and deduplicate.\n            df.final <- rbind(df.final, df.final.extra.genes)\n            df.final <- df.final[!duplicated(df.final),] \n            rownames(df.final) <- df.final$Gene\n            df.final$Gene <- NULL\n            df.final$var <- NULL\n        } else {\n            # Want to use ONLY user-provided gene list.\n            df.final <- df.final.extra.genes\n            df.final <- df.final[!duplicated(df.final),]\n            # Order genes in heatmap by user-submitted order of gene names.\n            df.final <- df.final[genes_to_include_parsed,]\n            #df.final$Gene <- NULL\n        }\n    } else {\n        df.final <- df.mat\n        df.final$Gene <- NULL\n    }\n    \n        ## Optionally apply centering and rescaling (default TRUE).\n    if (center_and_rescale_expression == TRUE) {\n            tmean.scale = t(scale(t(df.final)))\n            tmean.scale = tmean.scale[!is.infinite(rowSums(tmean.scale)),]\n            tmean.scale = na.omit(tmean.scale)\n    } else {\n            tmean.scale = df.final\n    }\n\n    if(order_by_gene_expression == TRUE){\n        gene_to_order_columns <- gsub(\" \",\"\",gene_to_order_columns)\n        if(gene_expression_order == \"low_to_high\"){\n        tmean.scale <- tmean.scale[,order(tmean.scale[gene_to_order_columns,])] #order from low to high \n        } else{\n        tmean.scale <- tmean.scale[,order(-tmean.scale[gene_to_order_columns,])] #order from high to low  \n        }\n    }\n\n    df.final <- as.data.frame(tmean.scale)\n\n    ## Parse input sample metadata and add annotation tracks to top of heatmap.\n    annot <- sample_metadata\n    # Filter to only samples user requests.\n    annot=annot %>% dplyr::filter(.data[[sample_name_column]] %in% samples_to_include) \n    \n    # Arrange sample options.\n    if(arrange_sample_columns) {\n      annot = annot[match(samples_to_include,annot[[sample_name_column]]),]\n      for(x in group_columns){\n                annot[,x]= factor(annot[,x],levels=unique(annot[,x]))  \n        }       \n      annot = annot %>% dplyr::arrange_(.dots=group_columns,.by_group = TRUE)\n      df.final <- df.final[,match(annot[[sample_name_column]],colnames(df.final))] \n    }\n    \n    # Build subsetted sample metadata table to use for figure.\n    colorlist <- c(\"#5954d6\",\"#e1562c\",\"#b80058\",\"#00c6f8\",\"#d163e6\",\"#00a76c\",\"#ff9287\",\"#008cf9\",\"#006e00\",\"#796880\",\"#FFA500\",\"#878500\")\n    names(colorlist) <- c(\"indigo\",\"carrot\",\"lipstick\",\"turquoise\",\"lavender\",\"jade\",\"coral\",\"azure\",\"green\",\"rum\",\"orange\",\"olive\")\n    group_colors <- colorlist[group_colors]\n\n    annot %>% dplyr::select(group_columns) -> annotation_col    \n    annotation_col = as.data.frame(unclass(annotation_col))\n    annotation_col[] <- lapply(annotation_col,factor)\n    x <- length(unlist(lapply(annotation_col,levels)))\n    if(x>length(group_colors)){\n        k=x-length(group_colors)\n        more_cols<- getourrandomcolors(k) \n        group_colors <- c(group_colors, more_cols)\n    }\n    rownames(annotation_col) <- annot[[sample_label_column]]\n    annot_col = list()\n    b=1\n    i=1\n    while (i <= length(group_columns)){\n        nam <- group_columns[i]\n        grp <- as.factor(annotation_col[,i])\n        c <- b+length(levels(grp))-1\n        col = group_colors[b:c]\n        names(col) <- levels(grp)\n        assign(nam,col)\n        annot_col = append(annot_col,mget(nam))\n        b = c+1\n        i=i+1\n    }\n\n    if(assign_group_colors == TRUE){\n            colassign <- assign_color_to_sample_groups\n            groupname <- c()\n            groupcol <- c() \n            for (i in 1:length(colassign)) {\n                groupname[i] <- strsplit(colassign[i], \": ?\")[[1]][1]\n                groupcol[i] <- strsplit(colassign[i], \": ?\")[[1]][2]\n            }\n            annot_col[[1]][groupname] <- groupcol\n    }\n\n    ## Setting labels_col for pheatmap column labels.\n    \n    ## Set order of columns based on smaple name input\n    #colnames(df.final)%>%print\n    #df.final=df.final[,c(samples_to_include)]\n\n    if (manually_rename_samples == TRUE) {\n        # Use user-provided names to rename samples.\n        replacements = samples_to_rename\n        old <- c()\n        new <- c()\n        labels_col <- colnames(df.final)\n        for (i in 1:length(replacements)) {\n            old <- strsplit(replacements[i], \": ?\")[[1]][1]\n            new <- strsplit(replacements[i], \": ?\")[[1]][2]\n            old=gsub(\"^[[:space:]]+|[[:space:]]+$\",\"\",old)\n            new=gsub(\"^[[:space:]]+|[[:space:]]+$\",\"\",new)\n            labels_col[labels_col==old]=new           \n        }\n    } else {\n        \n        #annot=annot[match(colnames(df.final),annot[[sample_name_column]]),]\n        #print(annot[[sample_label_column]])\n        #print(colnames(df.final))\n        #colnames(df.final)=annot[[sample_label_column]]\n\n        old=annot[[sample_name_column]]\n        new=annot[[sample_label_column]]\n            names(old)=new\n            df.final=rename(df.final,any_of(old))\n        labels_col <- colnames(df.final)\n    }\n\n    ## Print number of genes to log.\n    print(paste0(\"The total number of genes in heatmap: \", nrow(df.final)))\n\n    ## Make the final heatmap.\n    p <- doheatmap(dat=df.final, clus=cluster_samples, clus2=cluster_genes, ht=50, rn=display_gene_names, cn=display_sample_names, col=heatmap_color_scheme, dispnum=display_numbers)\n    p@matrix_color_mapping@name <- \" \"\n    p@matrix_legend_param$at <- as.numeric(formatC(p@matrix_legend_param$at, 2))\n    p@column_title_param$gp$fontsize <- 10\n    print(p)\n\n    ## If user sets toggle to TRUE, return Z-scores.\n    ## Else return input counts matrix by default (toggle FALSE).\n    ## Returned matrix includes only genes & samples used in heatmap.\n    if(return_z_scores){\n        df.new <- data.frame(tmean.scale) # Convert to Z-scores.\n        df.new %>% rownames_to_column(\"Gene\") -> df.new\n        return(df.new)\n    } else {\n        df.final %>% rownames_to_column(\"Gene\") -> df.new\n        return(df.new)\n    }\n}\n\n\n## ---------------------------- ##\n## Global Imports and Functions ##\n## ---------------------------- ##\n\n## Functions defined here will be available to call in\n## the code for any table.\n\n## --------------- ##\n## End of Template ##\n## --------------- ##\n",
	"columns": [
		{
			"key": "Gene_Column_Name",
			"displayName": "Gene Column Name",
			"description": "Column containing gene names.",
			"paramGroup": "Data Setup",
			"sourceDataset": "Counts_Matrix",
			"defaultValue": null,
			"columnType": "STRING",
			"isMulti": null
		},
		{
			"key": "Sample_Name_Column",
			"displayName": "Sample Name Column",
			"description": "Column containing sample names.",
			"paramGroup": "Data Setup",
			"sourceDataset": "Sample_Metadata",
			"defaultValue": null,
			"columnType": "ALL",
			"isMulti": null
		},
		{
			"key": "Sample_Labels_Column",
			"displayName": "Sample Labels Column",
			"description": "Select column from metadata that contains the sample names that will appear as column names on the heatmap.",
			"paramGroup": "Data Setup",
			"sourceDataset": "Sample_Metadata",
			"defaultValue": null,
			"columnType": "ALL",
			"isMulti": null
		},
		{
			"key": "Samples_to_Include",
			"displayName": "Samples to Include",
			"description": "Select the sample columns from the input counts matrix that you want to include in the heatmap. Only numeric columns can be selected.",
			"paramGroup": "Data Setup",
			"sourceDataset": "Counts_Matrix",
			"defaultValue": null,
			"columnType": "NUMBER",
			"isMulti": true
		},
		{
			"key": "Reorder_Sample_Dendrogram_Order",
			"displayName": "Reorder Sample Dendrogram Order",
			"description": "Reorder the samples (columns) of the dendrogram by name, e.g. “sample2”,“sample3\",“sample1\".",
			"paramGroup": "Sample",
			"sourceDataset": "Counts_Matrix",
			"defaultValue": null,
			"columnType": "ALL",
			"isMulti": true
		},
		{
			"key": "Group_Columns",
			"displayName": "Group Columns",
			"description": "Columns containing the sample groups for annotation tracks",
			"paramGroup": "Annotation",
			"sourceDataset": "Sample_Metadata",
			"defaultValue": null,
			"columnType": "ALL",
			"isMulti": true
		}
	],
	"condaDependencies": [],
	"description": "This template is intended for use with Bulk RNA-seq data. It generates a heatmap for normalized (or batch corrected) RNA-seq data.\n\nThis template takes as input an expression matrix and your sample metadata table. The expression matrix is usually (though not always) going to consist of your normalized or batch corrected counts. It should always have one row per gene, a first column of gene names, and one additional column per sample.\n\nBy default, the samples (i.e. the columns) are allowed to cluster in an unsupervised fashion based on how similar their expression profiles are across the included genes. This can help identify samples that are non clustering with their group as you might expect based on the experimental design.\n\nAgain, by default, the top 500 genes by variance are used, as these are generally going to include those genes that most distinguish your samples from one another. You can change this as well as many other parameters about this heatmap if you explore the advanced options.",
	"externalId": "Expression_Heatmap_CCBR_scRNA_seq_Bulk_",
	"inputDatasets": [
		{
			"key": "Counts_Matrix",
			"displayName": "Counts Matrix",
			"description": "Input counts dataset should have gene names in the first column and counts values for each sample in the remaining columns. This might be the raw counts dataset, the low-count-genes-removed counts dataset, the voom-normalized counts dataset, or the batch corrected counts dataset.",
			"paramGroup": null,
			"anchorDataset": false,
			"dataType": "R_NATIVE_DATAFRAME",
			"tags": []
		},
		{
			"key": "Sample_Metadata",
			"displayName": "Sample Metadata",
			"description": "Dataset containing sample metadata created or modified by using Actions dropdown menu (upper-right) > Enter Sample Metadata. Must include columns for Sample Name, Group, Batch, and Label.",
			"paramGroup": null,
			"anchorDataset": false,
			"dataType": "R_NATIVE_DATAFRAME",
			"tags": []
		}
	],
	"vectorLanguage": "R",
	"codeLanguage": "R",
	"parameters": [
		{
			"key": "Include_All_Genes",
			"displayName": "Include All Genes",
			"description": "Set to TRUE if all genes are to be included.  Set to FALSE if you want to filter genes by variance and/or provide a list of specific genes that will appear in the heatmap.",
			"paramType": "BOOLEAN",
			"paramGroup": "Gene",
			"paramValues": null,
			"defaultValue": "FALSE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Filter_Top_Genes_by_Variance",
			"displayName": "Filter Top Genes by Variance",
			"description": "Set to TRUE if you want to only include the top genes by variance.  Set to FALSE if you do not want to filter genes by variance.",
			"paramType": "BOOLEAN",
			"paramGroup": "Gene",
			"paramValues": null,
			"defaultValue": "TRUE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Top_Genes_by_Variance_to_Include",
			"displayName": "Top Genes by Variance to Include",
			"description": "The number of genes to include if filtering genes by variance. This parameter is ignored if \"Filter top genes by variance\" is set to FALSE.",
			"paramType": "NUMBER",
			"paramGroup": "Gene",
			"paramValues": null,
			"defaultValue": "500",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Specific_Genes_to_Include_in_Heatmap",
			"displayName": "Specific Genes to Include in Heatmap",
			"description": "Enter the gene symbols to be included in the heatmap, with each gene symbol separated with a space from the others. Alternatively, paste in a column of gene names from any spreadsheet application. This parameter is ignored if \"Include all genes\" is set to TRUE.",
			"paramType": "STRING",
			"paramGroup": "Gene",
			"paramValues": null,
			"defaultValue": "None",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Cluster_Genes",
			"displayName": "Cluster Genes",
			"description": "Choose whether to cluster the rows (genes). If TRUE, rows will have clustering applied. If FALSE, clustering will not be applied to rows.",
			"paramType": "BOOLEAN",
			"paramGroup": "Gene",
			"paramValues": null,
			"defaultValue": "TRUE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Gene_Clustering_Method",
			"displayName": "Gene Clustering Method",
			"description": "Clustering method metric to be used in clustering samples.",
			"paramType": "SELECT",
			"paramGroup": "Gene",
			"paramValues": [
				"ward.D",
				"ward.D2",
				"single",
				"complete",
				"average",
				"mcquitty",
				"median",
				"centroid"
			],
			"defaultValue": "average",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Gene_Distance_Metric",
			"displayName": "Gene Distance Metric",
			"description": "Distance metric to be used in clustering genes.",
			"paramType": "SELECT",
			"paramGroup": "Gene",
			"paramValues": [
				"euclidean",
				"maximum",
				"manhattan",
				"canberra",
				"binary",
				"minkowski",
				"correlation"
			],
			"defaultValue": "correlation",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Display_Gene_Dendrogram",
			"displayName": "Display Gene Dendrogram",
			"description": "Set to TRUE to show gene dendrograms.  Set to FALSE to hide dendrograms.",
			"paramType": "BOOLEAN",
			"paramGroup": "Gene",
			"paramValues": null,
			"defaultValue": "TRUE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Display_Gene_Names",
			"displayName": "Display Gene Names",
			"description": "Set to TRUE to display gene names on the right side of the heatmap. Set to FALSE to hide gene names.",
			"paramType": "BOOLEAN",
			"paramGroup": "Gene",
			"paramValues": null,
			"defaultValue": "FALSE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Center_and_Rescale_Expression",
			"displayName": "Center and Rescale Expression",
			"description": "Center and rescale expression for each gene across all included samples.",
			"paramType": "BOOLEAN",
			"paramGroup": "Gene",
			"paramValues": null,
			"defaultValue": "TRUE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Cluster_Samples",
			"displayName": "Cluster Samples",
			"description": "Choose whether to cluster the columns (samples). If TRUE, columns will have clustering applied. If FALSE, clustering will not be applied to columns.",
			"paramType": "BOOLEAN",
			"paramGroup": "Sample",
			"paramValues": null,
			"defaultValue": "TRUE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Arrange_Sample_Columns",
			"displayName": "Arrange Sample Columns",
			"description": "If TRUE, your samples will be arranged by the order that Groups are found in the \"Samples to Include\" parameter above. If FALSE, and \"Cluster Samples\" is FALSE, and \"Order by Gene Expression is FALSE, then samples will appear in the order of input (Samples to Include).",
			"paramType": "BOOLEAN",
			"paramGroup": "Sample",
			"paramValues": null,
			"defaultValue": "FALSE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Order_by_Gene_Expression",
			"displayName": "Order by Gene Expression",
			"description": "If TRUE, set gene name below and direction for ordering",
			"paramType": "BOOLEAN",
			"paramGroup": "Sample",
			"paramValues": null,
			"defaultValue": "FALSE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Gene_to_Order_Columns",
			"displayName": "Gene to Order Columns",
			"description": "Gene to order columns by expression levels",
			"paramType": "STRING",
			"paramGroup": "Sample",
			"paramValues": null,
			"defaultValue": " ",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Gene_Expression_Order",
			"displayName": "Gene Expression Order",
			"description": "Choose direction for gene order",
			"paramType": "SELECT",
			"paramGroup": "Sample",
			"paramValues": [
				"low_to_high",
				"high_to_low"
			],
			"defaultValue": "low_to_high",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Sample_Clustering_Method",
			"displayName": "Sample Clustering Method",
			"description": "Clustering method  to be used in clustering samples.",
			"paramType": "SELECT",
			"paramGroup": "Sample",
			"paramValues": [
				"ward.D",
				"ward.D2",
				"single",
				"complete",
				"average",
				"mcquitty",
				"median",
				"centroid"
			],
			"defaultValue": " ",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Sample_Distance_Metric",
			"displayName": "Sample Distance Metric",
			"description": "Distance metric to be used in clustering samples.",
			"paramType": "SELECT",
			"paramGroup": "Sample",
			"paramValues": [
				"euclidean",
				"maximum",
				"manhattan",
				"canberra",
				"binary",
				"minkowski",
				"correlation"
			],
			"defaultValue": "correlation",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Display_Sample_Dendrograms",
			"displayName": "Display Sample Dendrograms",
			"description": "Set to TRUE to show sample dendrograms.  Set to FALSE to hide dendrogram.",
			"paramType": "BOOLEAN",
			"paramGroup": "Sample",
			"paramValues": null,
			"defaultValue": "TRUE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Reorder_Sample_Dendrogram",
			"displayName": "Reorder Sample Dendrogram",
			"description": "If TRUE, set the order of the dendrogram (below)",
			"paramType": "BOOLEAN",
			"paramGroup": "Sample",
			"paramValues": null,
			"defaultValue": "FALSE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Display_Sample_Names",
			"displayName": "Display Sample Names",
			"description": "Set to TRUE if you want sample names to be displayed on the plot. Set to FALSE to hide sample names.",
			"paramType": "BOOLEAN",
			"paramGroup": "Sample",
			"paramValues": null,
			"defaultValue": "TRUE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Manually_Rename_Samples",
			"displayName": "Manually Rename Samples",
			"description": "Set to TRUE if you'd like to manually rename the sample names.",
			"paramType": "BOOLEAN",
			"paramGroup": "Sample",
			"paramValues": null,
			"defaultValue": "FALSE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Samples_to_Rename",
			"displayName": "Samples to Rename",
			"description": "Enter each sample to rename in the format:\n\nold_name: new_name\n\nThis parameter is ignored if \"Manually rename samples\" is set to FALSE.",
			"paramType": "VECTOR",
			"paramGroup": "Sample",
			"paramValues": null,
			"defaultValue": "c(\"\")",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Assign_Group_Colors",
			"displayName": "Assign Group Colors",
			"description": "If TRUE, set the groups assigned colors (below)",
			"paramType": "BOOLEAN",
			"paramGroup": "Annotation",
			"paramValues": null,
			"defaultValue": "FALSE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Assign_Color_to_Sample_Groups",
			"displayName": "Assign Color to Sample Groups",
			"description": "Enter each sample to color in the format: group_name: color This parameter is ignored if \"Assign Colors\" is set to FALSE. Use this link to select colors: https://nidap.nih.gov/workspace/preview-app/ri.blobster.main.pdf.7922ce2b-39d7-40e7-85ea-8b8146bbf363",
			"paramType": "VECTOR",
			"paramGroup": "Annotation",
			"paramValues": null,
			"defaultValue": "c()",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Group_Colors",
			"displayName": "Group Colors",
			"description": "Set group annotation colors.",
			"paramType": "MULTISELECT",
			"paramGroup": "Annotation",
			"paramValues": [
				"indigo",
				"carrot",
				"lipstick",
				"turquoise",
				"lavender",
				"jade",
				"coral",
				"azure",
				"green",
				"rum",
				"orange",
				"olive"
			],
			"defaultValue": "c(\"indigo\",\"carrot\",\"lipstick\",\"turquoise\",\"lavender\",\"jade\",\"coral\",\"azure\",\"green\",\"rum\",\"orange\",\"olive\")",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Heatmap_Color_Scheme",
			"displayName": "Heatmap Color Scheme",
			"description": "Color scheme for heatmap.",
			"paramType": "SELECT",
			"paramGroup": "Visual",
			"paramValues": [
				"Default",
				"Blue to Red",
				"Red to Vanilla",
				"Violet to Pink",
				"Bu Yl Rd",
				"Bu Wt Rd"
			],
			"defaultValue": "Default",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Autoscale_Heatmap_Color",
			"displayName": "Autoscale Heatmap Color",
			"description": "Set to TRUE to autoscale the heatmap colors between the maximum and minimum heatmap color parameters. If FALSE, set the heatmap colors between \"Set max heatmap color\" and \"Set min heatmap color\" (below).",
			"paramType": "BOOLEAN",
			"paramGroup": "Visual",
			"paramValues": null,
			"defaultValue": "TRUE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Set_Max_Heatmap_Color",
			"displayName": "Set Max Heatmap Color",
			"description": "If Autoscale heatmap color is set to FALSE, set the maximum heatmap z-score value.",
			"paramType": "NUMBER",
			"paramGroup": "Visual",
			"paramValues": null,
			"defaultValue": "2",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Set_Min_Heatmap_Color",
			"displayName": "Set Min Heatmap Color",
			"description": "If Autoscale heatmap color is set to FALSE, set the minimum heatmap z-score value.",
			"paramType": "NUMBER",
			"paramGroup": "Visual",
			"paramValues": null,
			"defaultValue": "-2",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Aspect_Ratio",
			"displayName": "Aspect Ratio",
			"description": "Set figure Aspect Ratio. Ratio refers to entire figure including legend. If set to Auto figure size is based on number of rows and columns form counts matrix. default - Auto",
			"paramType": "STRING",
			"paramGroup": "Visual",
			"paramValues": null,
			"defaultValue": "Auto",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Display_Numbers",
			"displayName": "Display Numbers",
			"description": "Setting to FALSE (default) will not display numerical value of heat on heatmap. Set to TRUE if you want to see these numbers on the plot.",
			"paramType": "BOOLEAN",
			"paramGroup": "Visual",
			"paramValues": null,
			"defaultValue": "FALSE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Gene_Name_Font_Size",
			"displayName": "Gene Name Font Size",
			"description": "Font size for gene names. If you don't want gene labels to show, toggle \"Display Gene Names\" below to FALSE",
			"paramType": "NUMBER",
			"paramGroup": "Visual",
			"paramValues": null,
			"defaultValue": "4",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Legend_Font_Size",
			"displayName": "Legend Font Size",
			"description": "Set Font size for figure legend. Default is 10.",
			"paramType": "NUMBER",
			"paramGroup": "Visual",
			"paramValues": null,
			"defaultValue": "10",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Sample_Name_Font_Size",
			"displayName": "Sample Name Font Size",
			"description": "Font size for sample names. If you don't want to display samples names, toggle \"Display sample names\" (below) to FALSE",
			"paramType": "NUMBER",
			"paramGroup": "Visual",
			"paramValues": null,
			"defaultValue": "8",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		},
		{
			"key": "Return_Z_Scores",
			"displayName": "Return Z-Scores",
			"description": "Toggle is OFF by default, which returns the expression dataset that was the input for the heatmap. However, sometimes you want the Z-scores that are calculated to draw this specific heatmap. To return the Z-scores instead of the expression values, switch this toggle to ON.",
			"paramType": "BOOLEAN",
			"paramGroup": "Advanced",
			"paramValues": null,
			"defaultValue": "FALSE",
			"condition": null,
			"content": null,
			"objectPropertyReference": null
		}
	],
	"title": "Expression Heatmap [CCBR] [scRNA-seq] [Bulk]",
	"templateApiVersion": "0.1.0"
}